\input texinfo_times.tex
@setfilename spring.info
@settitle Introduction to the Spring Framework
@paragraphindent 1
@tex
\global\bindingoffset=0.00in
\global\normaloffset =0.00in
@end tex
@dircategory Spring Framework
@direntry
* Spring Framework: (spring).                 Spring Framework
@end direntry
@set xref-automatic-section-title
@smallbook
@set EDITION 1.0
@set VERSION 2.0.x
@set UPDATED 2007-06-03
@set ISBN X-XXXXXX-XX-X
@titlepage
@sp 
@title Introduction to the Spring Framework
@subtitle For Spring version @value{VERSION}
@sp 4
@author by Bill Six
@page
@vskip 0pt plus 1filll
This manual documents the Spring Framework version @value{VERSION}.
@sp2
@multitable @columnfractions .50 .50
@item Published by:              @tab
@item @tab
@item Bill Six Press                  
@end multitable
@sp 2
Copyright @copyright{} 2007 Bill Six
@sp 1
Permission is granted to copy, distribute and/or modify this document
under the terms of the @acronym{GNU} Free Documentation License,
Version 1.2, or any later version published by the Free Software
Foundation.
@end titlepage
@page
@contents
@headings off
@iftex
@shorttitlepage Introduction to the Spring Framework
@end iftex
@headings on

@node Introduction
@chapter Introduction
@c %MENU% Purpose of the Spring Framework

While Hibernate is an excellent object-relational mapping tool which supplanted EJB 2.1's EntityBeans 
as the persistance mechanism of choice for many Java developers, Hibernate does not offer a unified
interface for transaction management in the Service Layer.  The Spring Framework does however, 
allowing integration of custom code to a local transaction or a JTA transaction.
Furthermore, Spring's transaction management also includes support for the delivery and asynchronous consumption
of JMS messages.

The Spring Framework's main strength is that it provides interfaces as an abstraction over existing libraries 
with similar functionality.  Specifically, these services are transaction management, dynamic proxy creation, and
data access technologies.

While a plethora of documentation regarding Spring exists in books and on the web, most of it emphasizes the use of an XML-based 
ApplicationContext for the purpose of Depedency Injection and Aspect Oriented Programming.  While these may or may not have
their merits, I choose to focus instead on the abstractions Spring provides over existing JavaEE technologies.

I wrote this paper because it's the paper I would have liked to have read when I first picked up Spring after college.

@node Getting Started,  , Introduction
@section Getting Started

This paper is written with the assumption that you are at least
somewhat familiar with the Java programming language and basic
programming concepts.  Additionally, it is assumed that you have read Martin Fowler's 
@emph{Patterns of Enterprise Application Architecture} (Addison-Wesley Professional, November 5, 2002), @uref{http://www.martinfowler.com/books.html#eaa}
, and Christian Bauer's and Gavin King's @emph{Hibernate in Action} (Manning Publications, August 1, 2004), @uref{http://www.manning.com/bauer/}

@node Method Interception 
@chapter Method Interception 
@c %MENU% Method Interception

Before getting Spring's integration with data access technologies and transaction management, it's important to understand what
method interception is and how to use dynamic proxies.  Modern Java frameworks make heavy use of dynamic proxies: Spring uses
them to simplify transaction management in the Service Layer, and Hibernate uses them to lazily load a subgraph of the persistant
object graph.

@node Dynamic Proxies,  , Method Interception 
@section Dynamic Proxies

Dynamic, message-passing object oriented languages such as Smalltalk-80, Objective C, Ruby, and Groovy  
allow an object to inspect messages which it receives should it not have a method which correspond to the message's 
selector@footnote{The method signature and in Java terminology}.  
The object can then decide to execute whatever actions it sees fit based on the selector and arguments
of the message.  This feature allows a developer to create proxy objects which forward these unknown messages
to another ``target'' object.

The statically-typed nature of Java mandates that an object cannot receive a message, or MethodInvocation in Spring's vernacular, 
for which it does not have a corresponding Method.  As such, a purely statically-typed system cannot allow
for arbitrary proxy objects.  In order to get around this limitation, 
 in JDK 1.3 Sun introduced the notion of dynamic proxies@footnote{I'm not quite sure
why the name ``dynamic'' proxy is used instead of just ``proxy''.  I'm guessing it's because you can statically 
type a proxy class which implements a ``dynamic'' set of interfaces}, which under the hood is
implemented using reflection.  A dynamic proxy is a Java class 
which, at runtime, can be configured as a proxy to any number of Java interfaces: thus allowing safe type-casting of the proxy object 
to a set of target interfaces.  Around the same time, an open source project called CGLIB appeared,
allowing similar proxying behavior via byte-code enhancement instead of reflection.  
At the time, performance issues aside, the additional benefit of CGLIB is that it removed the restriction
that a dynamic proxy can only proxy instances of interfaces, thus providing the ability to proxy an instance of a class.

Dynamic Proxies can be very useful in the Service Layer of an enterprise application.  The Service Layer is usually a thin
layer over a Domain Model which deals with transaction logic.  Each method in the Service Layer is likely to have similar
isolation and propagation levels, and as such, the Service Layer can contain redundant code.  To alleviate the
boilerplate code, a proxy object can be placed in front of the Service Layer object, allowing the concise expression 
of the transactional logic. 





@node Proxy Example - Smalltalk-80
@subsection Proxy Example - Smalltalk-80

The following example shows how proxy objects are implemented in Smalltalk.  Since the proxy object intercepts the method call
to the target object, the proxy object can perform logic before and after the actual method call is forwarded to the target.

@smallexample
 ProtoObject subclass: #CustomProxyClass
   instanceVariableNames: 'target'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Examples'
  
  initializeTarget: t 
   target := t

  doesNotUnderstand: aMessage 
   | toReturn |
   Transcript show: 'Here I would open a transaction'; cr.
   toReturn := target perform: aMessage selector withArguments: aMessage arguments.
   Transcript show: 'Here commit the transaction unless I caught an unrecoverable exception!';cr.
   ^ toReturn .
	
 Object subclass: #CalculatorService
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'CalculatorService'

  add: first and: second
   ^ first + second .

 ClassTestCase subclass: #CustomProxyClassTest
   instanceVariableNames: 'calculatorService'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'CalculatorService'

  setUp
   calculatorService := CustomProxyClass target: (CalculatorService new).

  testCalculatorService
   self assert: ( (calculatorService add: 1 and: 2) = 3)

@end smallexample





@node Dynamic Proxy Example - Spring
@subsection Dynamic Proxy Example - Spring

The following shows the same example implemented using the Java's dynamic proxies, initialized
through Spring.

@smallexample
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
public class TransactionInterceptor implements MethodInterceptor @{
    public Object invoke(MethodInvocation invocation) throws Throwable @{
        System.out.println("Here I would open a transaction");
        Object toReturn = invocation.proceed();
        System.out.println("Here commit the transaction unless I caught an unrecoverable exception!");
        return toReturn;
    @}
@}
public interface CalculatorService @{    
    public Integer add(Integer first, Integer second);
@}
public class CalculatorServiceImplementation implements CalculatorService @{    
    public Integer add(Integer first, Integer second) @{
        return first + second;
    @}
@}
import org.springframework.aop.framework.ProxyFactoryBean;

public class CalculatorServiceTest extends TestCase @{
    public CalculatorServiceTest( String testName ) @{
        super( testName );
    @}
    public static Test suite() @{
        return new TestSuite( CalculatorServiceTest.class );
    @}
    public void setUp() throws Exception@{
        CalculatorServiceImplementation target = new CalculatorServiceImplementation();
        ProxyFactoryBean factory = new ProxyFactoryBean();
        factory.addAdvice(new TransactionInterceptor());
        factory.setTarget(target);
        factory.setProxyInterfaces(new Class[]@{CalculatorService.class@});
        calculatorService = (CalculatorService) factory.getObject();
    @}
    public void testValidAccess() @{
        assertTrue(calculatorService.add(4,5) == 9);
    @}
    CalculatorService calculatorService ;
@}

@end smallexample


Spring's main contribution to dynamic proxies is that it allows you to
code your dynamic proxy using the AOPAlliance's interfaces, and the determination of the actual implementation
technology is defered until instance creation of the proxy by the ProxyFactoryBean.  In the example above, the ProxyFactoryBean 
defaults to using the JDK's dynamic proxy mechanism.  To use the CGLIB implementation,
you would just need to call factory.setProxyTargetClass(true); before calling factory.getObject().

@node Data Access Layer 
@chapter Data Access Layer
@c %MENU% Data Access 

Unlike the previous section on dynamic proxies, the methods in which people solve persistence greatly 
varies@footnote{See Table Data Gateway, Row Data Gateway, and Data Mapper in PoEAA}.
There exist full fledged object-relational mappers like Hibernate and the Java Persistence API, to lighter weight solutions 
like iBatis or JDBC.  With all the variation, it would not be feasable to define a set of interfaces
which define common data access behavior across them all.

However, what is possible is to define a data access technology agnostic set of DataAccessExceptions to simplify the commit/rollback 
transactional logic in the Service Layer.  Furthermore, given
dynamic proxies, you could integrate with each of the aforementioned technologies and put a dynamic proxy in front of them.
This proxy catches all of the Exceptions thrown in the Data Access Tier and recasts them as the Spring DataAccessExceptions. 



@node Data Mappers,  , Data Access Layer 
@section Data Mappers

The following is a Layer Supertype for Hibernate based DataMappers which uses Java 5's generics
so that subclasses can inherit each method without needing type-casts.

@smallexample
public class HibernateBaseDataMapper<T> implements BaseDataMapper<T>@{
    public HibernateBaseDataMapper() @{
        _persistentClass =  (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
    @}
    public T load(Long id) @{
        T entity = (T) _sessionFactory.getCurrentSession().load(_persistentClass, id);
        Hibernate.initialize(entity);
        return entity;
    @}
    public List<T> findAll() @{
        return findByCriteria();
    @}
    protected List<T> findByExample(T exampleInstance, String[] excludeProperty) @{
        Criteria crit = _sessionFactory.getCurrentSession().createCriteria(_persistentClass);
        Example example =  Example.create(exampleInstance);
        for (String exclude : excludeProperty) @{
            example.excludeProperty(exclude);
        @}
        crit.add(example);
        return crit.list();
    @}
    protected List<T> findByCriteria(Criterion... criterion) @{
        Criteria crit = _sessionFactory.getCurrentSession().createCriteria(_persistentClass);
        for (Criterion c : criterion) @{
            crit.add(c);
        @}
        return crit.list();
    @}
    public T saveOrUpdate(T entity) @{
        _sessionFactory.getCurrentSession().saveOrUpdate(entity);
        return entity;
    @}
    public void delete(T entity) @{
        _sessionFactory.getCurrentSession().delete(entity);
    @}
    public void flush() @{
        _sessionFactory.getCurrentSession().flush();
    @}
    public void clear() @{
        _sessionFactory.getCurrentSession().clear();
    @}
    public void setSessionFactory(SessionFactory sessionFactory) @{
        _sessionFactory = sessionFactory;
    @}
    protected SessionFactory _sessionFactory ;
    private Class<T> _persistentClass;
@}
@end smallexample

Concrete subclasses can inherit the base functionality, while adding
its own functionality.

@smallexample
public class HibernateAccountDataMapper extends HibernateBaseDataMapper<Account> implements AccountDataMapper@{
    public HibernateAccountDataMapper() @{
    @}
    public Account load(final String username) @{        
        Account toReturn = (Account) _sessionFactory.getCurrentSession()
                .createQuery("from Account as account where account._username like :username")
                .setParameter("username", username, Hibernate.STRING)
                .uniqueResult();        
        if(toReturn == null) @{
            throw new DataRetrievalFailureException("No user with name " + username + " exists");
        @}
        return toReturn;
    @}
    public Account fetchAccountTransactions(final Account account) @{
        Hibernate.initialize(account.getTransactionHistory());
        return account;
    @}
@}
@end smallexample


@node Configuration,  , Data Access Layer 
@section Configuration


These DataMappers need to connect to a datasource and take place in a transactional context.  
Instead of using an XML-based ApplicationContext, this can be implemented in pure Java
by using a Service Locator.


Hibernate needs a data source to connect to:
@smallexample
private BasicDataSource _dataSource ;
private void initializeDataSource() @{
  _dataSource = new BasicDataSource();
  _dataSource.setDriverClassName("org.postgresql.Driver");
  _dataSource.setUrl("jdbc:postgresql://localhost/hibernatetest");
  _dataSource.setUsername("wsix");
  _dataSource.setPassword("password");
@}
@end smallexample




Spring uses a LocalSessionFactoryBean to create a Hibernate SessionFactory.
@smallexample
private LocalSessionFactoryBean _localSessionFactoryBean;
private void initializeSessionFactory() throws Exception @{
  _localSessionFactoryBean = new LocalSessionFactoryBean();
  Properties hibernateProperties = new Properties();
  hibernateProperties.setProperty(
       "hibernate.dialect","org.hibernate.dialect.PostgreSQLDialect");
  _localSessionFactoryBean.setDataSource(_dataSource);
  _localSessionFactoryBean.setMappingResources(
       new String[]@{"com/billsix/examples/atm/DomainObjects.hbm.xml"@});
  _localSessionFactoryBean.setHibernateProperties(hibernateProperties);
  _localSessionFactoryBean.afterPropertiesSet();
@}
public void dropAndCreateSchemas() @{
  _localSessionFactoryBean.dropDatabaseSchema();
  _localSessionFactoryBean.createDatabaseSchema();
@}
@end smallexample



Here we create the HibernateAccountDataMapper.  Spring is able to catch and rethrow HibernateExceptions
as Spring's DataAccessExceptions because the SessionFactory that is set on the HibernateAccountDataMapper
is a dynamic proxy of Hibernate's SessionFactory.
@smallexample
private AccountDataMapper _accountDataMapper;
private void initializeAccountDataMapper() throws BeanInitializationException, IllegalArgumentException @{
  HibernateAccountDataMapper hibernateAccountDataMapper = 
                              new HibernateAccountDataMapper();
  hibernateAccountDataMapper.setSessionFactory(
                (SessionFactory)_localSessionFactoryBean.getObject());
  _accountDataMapper = hibernateAccountDataMapper;
  addTransactionInterceptorToAccountDataMapper();          
@}
public  AccountDataMapper getAccountDataMapper() @{
  return _accountDataMapper;
@}
@end smallexample




This brings me to my one complaint with Spring's design.  Each of these objects have empty constructors,
and properties must be set using setter methods.  After all of the required properties are set, afterPropertiesSet()
must be called.  I would prefer if Spring exposed constructors that took in the required properties, and within the
constructor, afterPropertiesSet() would be called.  This would guarantee that objects are initialized correctly,
and would cut down on the amount of code needed within the Service Locator.


      

@node Service Layer
@chapter Service Layer
@c %MENU% Service Layer

The Service Layer is where Spring's main strengths lie.  Dynamic Proxies and Introductions are most useful at this layer,
where there is normally a lot of boilerplate code in transaction management, authentication and authorization, and logging.



@node Transaction Management  , Service Layer
@section Transaction Management

Spring allows you to develop your Service Layer code completely independently of a specific transaction technology.  Whether
you are developing code which accesses one database, or whether you are accessing a database and a message queue
in a JTA distributed transaction; if your transactional context needs to change, all that you need to modify 
is the configuration in your Service Locator.

Spring defines an interface called the PlatformTransactionManager, for which there are multiple implementations.
These include the HibernateTransactionManager, JTATransactionManager, and others.  By having the 
PlatformTransactionManager interface, transaction management code in the Service Layer can be developed 
irregardless of the underlying transaction management scheme.

On another note, if most of the methods in each service in the Service Layer are transactional and have the same isolation
and propogation levels, dynamic proxies can be utilized to eliminate boilerplate transactional code.


@node Configuration,  , Service Layer
@section Configuration

Again, instead of using an XML-based ApplicationContext, the following is added to the Service Locator.

@smallexample
private PlatformTransactionManager _transactionManager  ;
private void initializeTransactionManager() @{
  HibernateTransactionManager hibernateTransactionManager = 
                               new HibernateTransactionManager();
  hibernateTransactionManager.setSessionFactory(
     (org.hibernate.SessionFactory)_localSessionFactoryBean.getObject());
  hibernateTransactionManager.afterPropertiesSet();
  _transactionManager = hibernateTransactionManager;
@}
public PlatformTransactionManager getTransactionManager() @{
  return _transactionManager;
@}
@end smallexample



Here we add a TransactionInterceptor to force all methods in the ATMService class to
perform in transactions, at the database's default isolation level.

@smallexample
private void addTransactionInterceptorToATM() throws AopConfigException @{
    NameMatchTransactionAttributeSource transactionAttributeSource = new NameMatchTransactionAttributeSource() ;
    DefaultTransactionAttribute transactionAttribute = new DefaultTransactionAttribute();
    transactionAttribute.setIsolationLevel(transactionAttribute.ISOLATION_DEFAULT);
    transactionAttribute.setPropagationBehavior(transactionAttribute.PROPAGATION_REQUIRED);
    transactionAttributeSource.addTransactionalMethod("*", transactionAttribute);
    TransactionInterceptor transactionInterceptor = new TransactionInterceptor();
    transactionInterceptor.setTransactionManager(_transactionManager);
    transactionInterceptor.setTransactionAttributeSource(transactionAttributeSource);
    transactionInterceptor.afterPropertiesSet();        
    ProxyFactoryBean proxyFactoryBean = new ProxyFactoryBean();
    proxyFactoryBean.addAdvice(transactionInterceptor);
    proxyFactoryBean.setTarget(_atmService);
    _atmService = (ATMService) proxyFactoryBean.getObject();        
@}
@end smallexample




@node Remoting
@chapter Remoting
@c %MENU% Remoting


Spring integrates with many different remoting technologies, such as RMI, Hessian, Burlap, and Spring's own
RMI over HTTP.  For the most part, these technologies are pretty interchangable.  However, remoting schemes such as
Hessian and Burlap that use reflection-based serialization instead of native Java serialization
fail when the domain model is persisted using Hibernate, or possibly any other bytecode-enhanced dynamic proxies.  

One of the best features of Hibernate is that
it allows a developer to fetch a specified subgraph of the persistent Domain Model object graph (thus, solving the n+1 select problem). 
If the object graph is reasonably complex, it's common for some of the objects in the fetched subgraph to reference objects that were not fetched in
the database roundtrip.  Hibernate does not model this dangling reference with a null pointer; instead, since Hibernate 
uses CGLIB's dynamic proxies, the dangling reference is a proxy object to the unfetched object in the database.  Upon
method calls to that dynamic proxy, the proxy attempts to fetch the target object from the database.  This means that if you're outside of the
Service Layer
and as such the Hibernate Session (Hibernate's Unit Of Work) is closed, an Exception will be thrown.  Thus, reflection-based
serialization techniques as employed by Hessian and Burlap fail.


RMI over HTTP is a good choice if you want to use RMI but you are behind a firewall.




@node Conclusion
@chapter Conclusion
@c %MENU% Conclusion

The Spring Framework is an excellent library for the Java programming language
whose main strengths occur in the Service Layer of enterprise application development.

This document, and all sample code can be downloaded from anonymously via subversion.

@smallexample
svn co https://atmexample.svn.sourceforge.net/svnroot/atmexample
@end smallexample

In addition to the dynamic proxy examples in this paper, it has a relatively simple
ATM application: using PostgreSQL, Hibernate, Spring, with a Swing and a JavaServer Faces
frontend.




@c Local Variables:
@c ispell-local-pdict: "ispell-dict"
@c End:
@bye

