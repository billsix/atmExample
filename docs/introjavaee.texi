\input texinfo 
@setfilename introjavaee.info
@settitle  JavaEE using Hibernate, Spring, and JSF
@paragraphindent 1
@tex
\global\bindingoffset=0.00in
\global\normaloffset =0.00in
@end tex
@dircategory Hibernate, Spring, and JSF
@direntry
* Hibernate, Spring, and JSF: (javaee).                 Hibernate, Spring, and JSF
@end direntry
@set xref-automatic-section-title
@smallbook
@set EDITION 1.0
@set VERSION 2.0.x
@set UPDATED 2007-06-03
@set ISBN X-XXXXXX-XX-X
@titlepage
@sp 
@title Introduction to JavaEE
@subtitle Using Hibernate 3.2.x, Spring 2.0.x, and JSF 1.2
@sp 4
@author by Bill Six
@page
@vskip 0pt plus 1filll
@sp
Copyright @copyright{} 2007 Bill Six
@sp 1
Permission is granted to copy, distribute and/or modify this document
under the terms of the @acronym{GNU} Free Documentation License,
Version 1.2, or any later version published by the Free Software
Foundation.
@end titlepage
@page
@contents
@headings off
@headings on




@node Introduction
@chapter Introduction


The purpose of this paper is to show how to use Hibernate, Spring, and JavaServer Faces to
structure an enterprise application.  To facilitate the readers understanding, I have created
a simple application which almost everybody uses - an ATM.

I wrote this paper because it's the paper I would have liked to have read when I first started
work after college.


@node Road Map,  , Introduction

@section Road Map
@itemize @bullet

@item
Chapter 2 - The User Stories. All examples in this paper will be driven by User Stories.

@item
Chapter 3 - The Domain Model. This section shows how to create a Domain Model to
implement all of the User Stories which involve the business logic.

@item
Chapter 4 - The Proxy Pattern, introduces a core technology that Hibernate and Spring
use internally.

@item
Chapter 5 - Data Access Layer, introduces Hibernate, an object-relational mapper used to save
a domain model to a relational database.  It will discuss the basics
of the impedance mismatch between objects and relational databases.
     
@item
Chapter 6 - Service Layer, is a short introduction to the Spring Framework.  It will show
how to use Spring to simplify transaction management in the service layer.

@item
Chapter 7 - UI Layer, is discusses JavaServer Faces, the JavaEE standard framework for
creating dynamic web pages.  

@end itemize



@node Layered Architecture,  , Introduction
@section Layered Architecture

Ideally, organizations structure their enterprise applications as depicted in the following
diagram.  The arrows represent method calls across layers.

@center{
@image{Layers}
}

The Domain Model is the core of an enterprise application.  A solid Domain Model encapsulates
the data and behavior of the business processes.  As my feeble diagram attempts to convey,
the Domain Model should be the focus of the entire application.


The responsibility of the User Interface is to display data to the user.  
To achieve this, the User Interface calls the Service Layer to retrieve a sub-graph of the persistent
Domain Model object graph.  Upon receiving this sub-graph, the User Interface calls
accessor methods, and displays the result.  After rendering this data, the end user of the application needs
to manipulate it.  The User Interface calls upon the Service Layer to mutate the data.

The Service Layer is a very thin layer which provides application logic
such as management of transactions, authentication and authorization,
and logging.  As such, the Service Layer mainly delegates method calls
to the Domain Model and Data Access Layer.  Because of its limited responsibilities, 
the Service Layer should fairly small.

The responsibility of the Data Access Layer is to retrieve and persist
sub-graphs of the persistent Domain Model object graph.


@node The User Stories
@chapter The User Stories
@c %MENU% The User Stories

This section describes the User Stories that will drive the application development.  
@footnote{You should read ``User Stories Applied'' by Mike Cohn}

@node Business Domain
@section Business Domain

The Business Domain is how people who use the system refer to the entities involved.  It is
developed as part of object-oriented analysis.


@itemize @bullet
@item
Account - An account is the base unit in which a person can transfer funds.  Each account
has a collection of fund transfers.
@item
Fund Transfer - Any action which involves increasing or decreasing the current balance of an account. 
A Fund Transfer needs to record the balance before the transaction, after the transaction, and the
time of the transaction.
@item
Deposit - A fund transfer which adds money to the account.
@item
Withdraw - A fund transfer which removes money from the account.
@end itemize





@node Roles
@section Roles

I find it helpful to not only define the roles for people using the application, but also
to define named users with sample data.  I find this helps to drive unit tests.


@itemize @bullet
@item
Bill - a person who has an account at our ATM.

@itemize @minus
@item
Username - wsix
@item
Password - password
@item
Initial balance = $100
@end itemize

@end itemize



@node User Stories
@section User Stories

The user stories are defined in the following format
@itemize @bullet

@item
Brief description of the user story
@itemize @minus
@item
Acceptance criteria
@end itemize
@end itemize

@*

@itemize @bullet

@item
Bill provides correct username and password before he can access any of the ATM's services
@itemize @minus
@item
Bill does not provide the correct username and password, and is unable to access any services
@item
Bill does provide the correct username and password, and is able to access all services
@end itemize

@item
Bill checks his current balance
@itemize @minus
@item
Bill's sees that he has $100.  
@end itemize

@item
Bill withdraws money from his account
@itemize @minus
@item
Bill's withdraws $50, and his current balance is now $50.  The Fund Transfer reflects
the before and after balance.
@end itemize

@item
Bill deposits money to his account
@itemize @minus
@item
Bill's deposits $50, and his current balance is now $150.  The Fund Transfer reflects
the before and after balance.

@end itemize

@item
Bill withdraws $50, deposits $25, is able to see a history of all of his fund transfers.
@itemize @minus
@item
Bill is able to see all of the fund transfers.
@end itemize
@end itemize








@node The Domain Model
@chapter The Domain Model

Rather than creating a class diagram to describe the Domain Model, I find that a good suite of 
unit tests not only drive the creation of a good Domain Model, they also provide adequate documentation.

@smallexample
public class AccountTest extends TestCase @{
    public AccountTest( String testName ) @{
        super( testName );
    @}
    public static Test suite() @{
        return new TestSuite( AccountTest.class );
    @}
    public void setUp() @{
        account = new Account("bill", "password", 100.00);
    @}
    public void testPasswordIsValid() @{
        assertTrue(account.passwordIsValid("password"));
        assertFalse(account.passwordIsValid("passw"));
    @}

@end smallexample

@itemize @bullet
@item
Bill checks his current balance
@itemize @minus
@item
Bill's sees that he has $100.  
@end itemize
@end itemize
@smallexample

    public void testCurrentBalance() @{
        assertTrue(account.getBalance() == 100.0);
    @}
@end smallexample


@itemize @bullet
@item 
Bill deposits money to his account
@itemize @minus
@item
Bill's deposits $50, and his current balance is now $150.  The Fund Transfer reflects
the before and after balance.
@end itemize
@end itemize

@smallexample
    public void testDeposit() @{
        account.deposit(50.00);
        assertTrue(account.getBalance() == 150.0);
        Set<FundTransfer> transactions = account.getFundTransferHistory(); 
        assertTrue(transactions.size()==1);
        FundTransfer transaction = transactions.iterator().next(); 
        assertTrue(transaction.getBalanceAfterTransaction() == 150.0);
        assertTrue(transaction.getBalanceBeforeTransaction() == 100.0);
    @}

@end smallexample

@itemize @bullet
@item
Bill withdraws money from his account
@itemize @minus
@item
Bill's withdraws $50, and his current balance is now $50.  The Fund Transfer reflects
the before and after balance.
@end itemize
@end itemize


@smallexample
    public void testWithdraw() @{
        account.withdraw(50.00);
        assertTrue(account.getBalance() == 50.0);
        Set<FundTransfer> transactions = account.getFundTransferHistory(); 
        assertTrue(transactions.size()==1);
        FundTransfer transaction = transactions.iterator().next(); 
        assertTrue(transaction.getBalanceAfterTransaction() == 50.0);
        assertTrue(transaction.getBalanceBeforeTransaction() == 100.0);
    @}

@end smallexample

@itemize @bullet
@item
Bill withdraws $50, deposits $25, is able to see a history of all of his fund transfers.
@itemize @minus
@item
Bill is able to see all of the fund transfers.
@end itemize
@end itemize

@smallexample
    public void testFundTransferHistory() @{
        account.withdraw(50.00);
        account.deposit(25.0);
        for(FundTransfer fundTransfer : account.getFundTransferHistory()) @{
            if(fundTransfer.getBalanceAfterTransaction() != 50.0 &&
                    fundTransfer.getBalanceAfterTransaction() != 75.0 ) @{
                fail("Incorrect set of fund transfers");
            @}
        @}
    @}
    private Account account;
@}
@end smallexample


@node The Proxy Pattern 
@chapter The Proxy Pattern 

This section has nothing to do with the User Stories, but before we get 
into Hibernate, Spring, and JSF, it's important to understand the 
Proxy pattern.  Modern Java frameworks such as Spring and Hibernate make heavy use of dynamic proxies; 
specifically Hibernate uses them to model unresolved references
in the Domain Model sub-graph, and Spring uses them to simplify transaction management.

@node Dynamic Proxies,  , The Proxy Pattern
@section Dynamic Proxies

Dynamic, message-passing object-oriented languages such as Smalltalk-80, Objective C, Ruby, and Groovy  
allow an object to inspect messages which it receives should it not have a method which correspond to the message's 
selector@footnote{The method signature and in Java parlance}.  
The object then decides to execute whatever action(s) it sees fit based on the selector and arguments
of the message.  This feature allows a developer to create proxy objects which forward these unknown messages
to another ``target'' object.@footnote{http://en.wikipedia.org/wiki/Proxy_pattern}
@footnote{In languages like Lisp where code is data, macros are a more elegant solution}

While dynamic languages support the Proxy pattern via the language's semantics, the statically-typed nature of 
Java mandates that an object cannot receive a message, or MethodInvocation in Spring's vernacular, 
for which it does not have a corresponding Method.  As such, a purely statically-typed system cannot allow
for proxy objects without manual delegation to the proxy.  In order to get around this limitation, 
Sun introduced the notion of a dynamic proxy in JDK 1.3
@footnote{I'm not quite sure
why the name ``dynamic'' proxy is used instead of just ``proxy''.  I'm guessing it's because you can statically 
type a proxy class which implements a ``dynamic'' set of interfaces}
, which is a Java class that can be configured as a proxy to any number of Java interfaces at runtime: thus allowing safe type-casting of the proxy object to a set of target interfaces.  Sun's implementation of this uses reflection.  
Around the same time, an open source project called CGLIB appeared, allowing similar proxying behavior 
via byte-code enhancement instead of reflection.  
The additional benefit of CGLIB is that it removed the restriction
that a dynamic proxy can only proxy instances of interfaces, thus providing the ability to proxy an instance of a class.



@node Proxy Example - Smalltalk-80
@subsection Proxy Example - Smalltalk-80

The following example shows how proxy objects are implemented in Smalltalk.  Since the proxy object intercepts the method call
to the target object, the proxy object can perform logic before and after the actual method call is forwarded to the target.

@smallexample
 ProtoObject subclass: #CustomProxyClass
   instanceVariableNames: 'target'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Examples'
  
  initializeTarget: t 
   target := t

  doesNotUnderstand: aMessage 
   | answer |
   Transcript show: 'Here I would open a transaction'; cr.
   answer := target perform: aMessage selector 
                    withArguments: aMessage arguments.
   Transcript show: 'Here commit the transaction unless I caught an unrecoverable exception!';cr.
   ^ answer .
	
 Object subclass: #CalculatorService
   instanceVariableNames: ''
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Examples

  add: first and: second
   ^ first + second .

 ClassTestCase subclass: #CustomProxyClassTest
   instanceVariableNames: 'calculatorService'
   classVariableNames: ''
   poolDictionaries: ''
   category: 'Examples

  setUp
   calculatorService := CustomProxyClass target: (CalculatorService new).

  testCalculatorService
   self assert: ( (calculatorService add: 1 and: 2) = 3)

@end smallexample





@node Dynamic Proxy Example - Spring
@subsection Dynamic Proxy Example - Spring

The following shows the same example implemented using the Java's dynamic proxies, initialized
through Spring.

@smallexample
import org.aopalliance.intercept.MethodInterceptor;
import org.aopalliance.intercept.MethodInvocation;
public class TransactionInterceptor implements MethodInterceptor @{
    public Object invoke(MethodInvocation invocation) throws Throwable @{
        System.out.println("Here I would open a transaction");
        Object answer = invocation.proceed();
        System.out.println("Here commit the transaction unless I \
caught an unrecoverable exception!");
        return answer;
    @}
@}
public interface CalculatorService @{    
    public Integer add(Integer first, Integer second);
@}
public class CalculatorServiceImplementation 
       implements CalculatorService @{    
    public Integer add(Integer first, Integer second) @{
        return first + second;
    @}
@}
import org.springframework.aop.framework.ProxyFactoryBean;

public class CalculatorServiceTest extends TestCase @{
    public CalculatorServiceTest( String testName ) @{
        super( testName );
    @}
    public static Test suite() @{
        return new TestSuite( CalculatorServiceTest.class );
    @}
    public void setUp() throws Exception@{
        CalculatorServiceImplementation target = 
                        new CalculatorServiceImplementation();
        ProxyFactoryBean factory = new ProxyFactoryBean();
        factory.addAdvice(new TransactionInterceptor());
        factory.setTarget(target);
        factory.setProxyInterfaces(new Class[]@{CalculatorService.class@});
        calculatorService = (CalculatorService) factory.getObject();
    @}
    public void testValidAccess() @{
        assertTrue(calculatorService.add(4,5) == 9);
    @}
    CalculatorService calculatorService ;
@}

@end smallexample


@node Data Access Layer 
@chapter Data Access Layer

The object-oriented model and the relational model have structural and
behavioral differences, called the impedance mismatch.


@node Structural Mismatch
@section Structural Mismatch

@b{Inheritance}

In the object-oriented model, objects can have superclasses and subclasses.
Relational databases do not have this notion.

@b{Collections}

In the object-oriented model, collections are implemented natively using the
object graph.  In the relational model, collections are represented using joins 
on foreign keys


@node Object structure
@subsection Object structure

Object oriented languages model data as an object graph, where an object
is represented by a node, and its collaborators are edges.  


@smallexample
public class Account extends BaseDomainObject@{
    ......
    private String username;
    private String password;
    private Double balance;
    private Set<FundTransfer> fundTransferHistory;
@}
public class FundTransfer extends BaseDomainObject@{
    ......
    private Account account;
    private Double balanceBeforeTransaction;
    private Double balanceAfterTransaction;
    private Calendar date;
@}
@end smallexample

@page

@center{
@image{ObjectGraph}
}
@footnote{from Fowler's PoEAA, a Value object is ``a small simple object, like money or a date range, whose equality isn't based on identity.''}

@node Relational structure
@subsection Relational structure

Relational databases model data as tables.  Data is stored
in columns.  Rows are uniquely identified by a primary key.  
Collections are represented by
foreign keys which map to another tables primary key.


@smallexample

CREATE SEQUENCE hibernate_sequence
  INCREMENT 1
  MINVALUE 1
  MAXVALUE 9223372036854775807
  START 3
  CACHE 1;

CREATE TABLE account
(
  id int8 NOT NULL,
  username varchar(255),
  password varchar(255),
  balance float8,
  version int8,
  CONSTRAINT account_pkey PRIMARY KEY (id)
) 
WITHOUT OIDS;

CREATE TABLE fundtransfer
(
  id int8 NOT NULL,
  balancebeforetransaction float8,
  balanceaftertransaction float8,
  date timestamp,
  version int8,
  account_id int8,
  CONSTRAINT fundtransfer_pkey PRIMARY KEY (id),
  CONSTRAINT fk5995fdf0980ea509 FOREIGN KEY (account_id)
      REFERENCES account (id) MATCH SIMPLE
      ON UPDATE NO ACTION ON DELETE NO ACTION
) 
WITHOUT OIDS;
@end smallexample


@center{@b{Table account}}


@multitable @columnfractions .2 .2 .2 .2 .2 
@headitem id @tab username @tab password @tab balance @tab version
@item 1
@tab bill
@tab password
@tab 50.0
@tab 1
@end multitable

@sp 2

@center{@b{Table fundtransfer}}

@multitable @columnfractions .16  .16 .16 .3 .16 .16 
@headitem id @tab before @tab after @tab date @tab version @tab account_id
@item 1
@tab 100.0
@tab 50.0
@tab 8/1/07 12:00
@tab 1
@tab 1
@end multitable




@node Overcoming the Structural Mismatch
@subsection Overcoming the Structural Mismatch

To overcome these structural differences, Hibernate uses Java 5's annotations
as meta-data.


@smallexample
@@Entity()
@@AccessType("field")
public class Account extends BaseDomainObject@{
    ......
    private String username;
    private String password;
    private Double balance;
    @@OneToMany(cascade = {CascadeType.ALL})
    @@JoinColumn(name="ACCOUNT_ID")
    private Set<FundTransfer> fundTransferHistory;
    @@Id @@GeneratedValue private Long id;
    @@Version private Long version;
@}

@@Entity()
@@AccessType("field")
public class FundTransfer extends BaseDomainObject@{
    ......
    @@ManyToOne( cascade = {CascadeType.ALL} )
    @@JoinColumn(name="ACCOUNT_ID")
    private Account account;
    private Double balanceBeforeTransaction;
    private Double balanceAfterTransaction;
    @@Temporal(TemporalType.TIMESTAMP) private Calendar date;
    @@Id @@GeneratedValue private Long id;
    @@Version private Long version;
@}

@end smallexample

@itemize @bullet
@item
The @@Entity() annotation lets Hibernate know that this object corresponds to a table, which
by default has the same name as the class.  By default, all Value objects map to columns
of the same name.
@item
The @@AccessType("field") annotation tells
Hibernate to populate the fields directly, instead of the default method of calling
the accessor methods.  
@item
The @@OneToMany and @@ManyToOne (along with a @@JoinColumn) 
annotations tell Hibernate that the collection is represented in the relational database
though foreign keys.  
@item
The @@Id @@GeneratedValue annotations tell Hibernate that this is the primary key,
and that Hibernate should generate a value upon insertion into the database.
@end itemize


@b{Collections}

Using the meta-data, Hibernate performs a join on the tables, and returns an 
instance of the Set interface.


@b{Inheritance}

Solving the inheritance mismatch is outside of the scope of this paper.  If you 
need to learn more, consult Hibernate's online documentation, and Martin Fowler's
Patterns of Enterprise Application Architecture.





@node Behavioral Mismatch
@section Behavioral Mismatch


@b{Object Identity}

In the object-oriented model, two objects are equal if they are located
in the same place in memory.  In a relational model, two rows are equal
if they have the same primary key. 



@node Overcoming the Behavioral Mismatch
@subsection Overcoming the Behavioral Mismatch


@b{Object Identity}

When using create/read/update/delete operations in Hibernate, Hibernate doesn't directly
execute your calls, it operates through Hibernate's Level 1 cache.  This 
thread-scoped@footnote{Because the cache is thread-scoped, a developer only needs to set
correct transaction isolation levels to deal with concurrency}
cache is a local copy of the user accessed sub-graph of the persistent object graph. 
As such,
the Level 1 cache acts as a buffer which ensures that each unique entry in the
database corresponds to the same Java object in memory. @footnote{This is described as the ``Identity Map''
in Martin Fowler's Patterns of Enterprise Application Architecture}





@node Unit of Work
@section Unit of Work

When the Service Layer calls mutator methods on the Domain model, the Domain Model
needs to flush its changes to the database upon the completion of the transaction.  

Hibernate could 
@itemize @bullet
@item 
Flush everything in the Level 1 cache to the database.  This would make for a lot of unnecessary SQL updates.
@item 
Force the developer to manually register which objects were modified, flushing only ``dirty'' objects.
@item 
Transparently register modified objects, flushing only ``dirty'' objects.
@end itemize


Hibernate uses the third method.


@node N+1 Selects Problem
@section N+1 Selects Problem

When Bill first logs into the ATM, he wants to check his balance, withdraw, deposit,
or view the entire history of his fund transfers.  When he first logs in, Hibernate
will pull back his Account object into the Level 1 cache, along with all of the
Value objects that the Account object references.  

Should Hibernate automatically load the entire
object graph into the Level 1 cache?  Assuming he just wants to check his current balance,
he has no need to pull back the thousands of previous fund transfers.

Hibernate could
@itemize @bullet
@item 
Load every object into the Level 1 cache that is referenced by any object in the Level 1 cache

@item 
Lazy-load all non-Value objects referenced by any objects in the Level 1 cache.  The Set of
FundTransfers will not be a null reference, it will be a reference to a dynamic proxy
@footnote{In this case, the dynamic proxy is an implementation of the ``Lazy Load'' pattern decribed in PoEAA} 
which can pull back the FundTransfers only when it is required.

@item 
Load a user-specified sub-graph of the persistent object graph into the Level 1 cache.
@end itemize

The first option is by far the worst.  There can be gigabytes of data stored in the database,
causing a simple read to pull back a large portion of the object graph when only a subset is 
required.

The second option is more sensible, and this was the model for EJB's before EJB 3.0.  The problem
with this model is that you may know that you want a specified sub-graph of the full object graph.
Lazy-loading will force multiple database roundtrips to fetch the sub-graph (hence the name
N+1 selects).

Hibernate (and now EJB 3.0) allows the third model, enabling loading a sub-graph in one database roundtrip. 

      

@node Service Layer
@chapter Service Layer


The Service Layer is a thin layer on top of a Domain Model which provides application logic
such as management of transactions, authentication and authorization,
and logging.  


There is only one User Story which deals with authorization.

@itemize @bullet
@item
Bill provides correct username and password before he can access any of the ATM's services
@itemize @minus
@item
Bill does not provide the correct username and password, and is unable to access any services
@item
Bill does provide the correct username and password, and is able to access all services
@end itemize
@end itemize


To implement this, I create a base interface for the Service Layer called Authenticatable.  This
class enables Bill to log in, and any Service Layer interface which implements Authenticatable
has access to the current account via the getAuthenticatedAccount() method.


@smallexample
@@Transactional(isolation=Isolation.DEFAULT,
                propagation=Propagation.REQUIRED)
public interface Authenticatable @{    
    public boolean authenticate(String username, String password);
    public Account getAuthenticatedAccount();
@}
@end smallexample

The Service Layer is also supposed to act as a thin layer over the Domain Model, exposing
methods that the User Interface needs to call.


@smallexample
@@Transactional(isolation=Isolation.DEFAULT,
                propagation=Propagation.REQUIRED)
public interface ATMService extends Authenticatable@{    
    public Double getBalance();    
    public void deposit(Double amountToDeposit);    
    public void withdraw(Double amountToWithdraw);    
    public Account fetchFundTransferHistory();
@}
@end smallexample

The @@Transactional annotation are Spring's way of setting isolation and propagation
levels for the Service.


@node Service Unit Test
@section Service Unit Test


The unit test for the Service Layer could then be implemented as follows.


@smallexample
public class ATMServiceTest extends TestCase @{
    public ATMServiceTest( String testName ) @{
        super( testName );
    @}
    public static Test suite() @{
        return new TestSuite( ATMServiceTest.class );
    @}
    .......
    public void testIncorrectLogin() @{
        if(atmService.authenticate("ll","password")) @{
            fail("Invalid user should not be able to log in");
        @}
        try@{
            atmService.withdraw(100.0);
            fail("Invalid user should not be able to use the ATM Service");
        @} catch(IllegalStateException ise) @{
        @}
    @}
    public void testCurrentBalance() @{
        if( !atmService.authenticate("bill","password")) @{
            fail("Valid user should be able to log in");
        @}
        assertTrue(atmService.getBalance() == 100.0);
    @}
    .......
@}




@end smallexample


@node Service Implementation
@section Service Implementation


@smallexample
public class ATMServiceImplementation implements ATMService@{
  public ATMServiceImplementation(SessionFactory sessionFactory) @{
      this.sessionFactory = sessionFactory;
  @}
@end smallexample

@itemize @bullet
@item
Calling sessionFactory.getCurrrentSession() gets Hibernate's Session, which accesses
the thread-local Session.  The Query uses Hibernate's 
HQL@footnote{HQL queries specify the sub-graph you want to load into the Level 1 cache}.
@end itemize  
@smallexample
  public boolean authenticate(String username, String password) @{
      Account account = (Account) sessionFactory.getCurrentSession()
      .createQuery("from Account as account where account.username like :username")
      .setParameter("username", username, Hibernate.STRING)
      .uniqueResult();
      if(account == null) @{
          return false;
      @}
      
      if(account.passwordIsValid(password)) @{
          this.account = account;
          return true;
      @}
      return false;
  @}
@end smallexample

@itemize @bullet
@item
Calling saveOrUpdate(object) on the session reattaches the ``detached'' instance
into the current transaction.  Although, since the account object will not have
changed in the UI, calling load(Account.class, this.account.getId()) would
perform better.
@end itemize 
@smallexample
  public Double getBalance() @{
      sessionFactory.getCurrentSession().saveOrUpdate(this.account);
      return this.account.getBalance();
  @}
  public void deposit(Double amountToDeposit) @{
      sessionFactory.getCurrentSession().saveOrUpdate(this.account);
      this.account.deposit(amountToDeposit);
  @}
  public void withdraw(Double amountToWithdraw) @{
      sessionFactory.getCurrentSession().saveOrUpdate(this.account);
      this.account.withdraw(amountToWithdraw);
  @}
@end smallexample

@itemize @bullet
@item
Since the FundTransfer set is lazily loaded, calling Hibernate.initialize(objects)
forces the fundHistory dynamic proxy to actually fetch the collection into
the Level 1 cache.
@end itemize
@smallexample
  public Account fetchFundTransferHistory() @{
      sessionFactory.getCurrentSession().saveOrUpdate(this.account);
      Hibernate.initialize(account.getFundTransferHistory());
      return account;
  @}
  public Account getAuthenticatedAccount() @{
      return this.account;
  @}
  private SessionFactory sessionFactory;
  private Account account;
@}
@end smallexample



@node Transaction Management  , Service Layer
@section Transaction Management

Spring defines an interface called the PlatformTransactionManager, for which there are multiple implementations; 
allowing you to develop your Service Layer code completely independently of a specific transaction technology.
These include the HibernateTransactionManager, JTATransactionManager, and others.  By having the 
PlatformTransactionManager interface, transaction management code in the Service Layer can be developed 
regardless of the underlying transaction management scheme.  






@node UI Layer
@chapter UI Layer


My personal preference is to use rich clients whenever possible, as I believe that end users
should be viewing computers as ``personal dynamic media''.  With a rich client application, 
the the UI layer can fetch a sub-graph of the Domain Model, and traverse it as the user
sees fit, only contacting the server
when the UI needs to invoke a method in the Service Layer.

However, to my dismay, HTML-based UIs have become the standard.

Since HTTP is inherently stateless, the Java Servlet API provides abstractions 
on top of HTTP which save
state for a web session@footnote{PoEAA discusses the various ways in which this is accomplished}.  

JavaServer Faces is built on top of the bare Java Servlet API, and
the user's session state is stored in a so called ``BackingBean''.  There is a multi-phase
lifecycle which is used to convert/validate the state from the user's form to the BackingBean.
JSF defines a basic suite of components, bound to model objects.  The JSF standard
only defines basic components for text, input boxes, submit boxes, tables, and a few more; however,
it is possible to create custom components.  JSF also has a XML-based system of page-flow

The JSF standard mandates that implementors provide JSP as a view technology.  JSPs process
pages in a linear order, as does PHP.  JSF has a much more complex lifecycle which doesn't quite
mesh with JSP.  Facelets is an alternate view technology which is much more in line
with the JSF lifecycle, so these examples will use Facelets as the view technology.




@node User Stories
@section User Stories


The User Interface needs to provide a few screens to implement the User Stories.




@itemize @bullet

@item
Bill provides correct username and password before he can access any of the ATM's services

@center{@image{login}}


@item
Welcome page.  It wasn't specified in the User Stories, but I felt it was needed.

@image{main}

@item
Bill checks his current balance

@image{currentbalance}

@item
Bill withdraws money from his account

@image{withdraw}

@item
Bill deposits money to his account

@center{@image{deposit}}

@item
Bill withdraws $50, deposits $25, is able to see a history of all of his fund transfers.


@center{@image{transactiondetails}}

@item
A fund transfer page.  I admit this is goldplating.  It wasn't in the User Stories.  I put this in
only to show how an individual element of a table is selected.

@center{@image{fundtransfer}}

@end itemize



@node Login Page
@section Login Page

@smallexample
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:h="http://java.sun.com/jsf/html">
 <body>
@end smallexample
@itemize @bullet
@item 
All data is stored in forms
@end itemize
@smallexample
  <h:form id="atmLoginForm">
   <p>
    <h:outputLabel for="nameInput">
@end smallexample
@itemize @bullet
@item 
Output texts can be used for i18n and l10n
@end itemize
@smallexample
    <h:outputText id="nameInputLabel"
                  value="Username:"/>
    </h:outputLabel>
@end smallexample
@itemize @bullet
@item 
The value in this input text is bound to the backing bean's username field.
If none is specified, the JSF lifecycle will abort early, and the message tag
will be activated
@end itemize
@smallexample
    <h:inputText id="nameInput" value="@#@{atmServiceBackingBean.username@}" 
                 required="true">
    </h:inputText>
    <h:message id="errors" for="nameInput" style="color: red"/>
   </p>
   <p>
    <h:outputLabel for="Password">
      <h:outputText id="passInputLabel"
                    value="Password:"/>
      </h:outputLabel>
    <h:inputSecret id="Password" value="@#@{atmServiceBackingBean.password@}"
                   required="true">
    </h:inputSecret>
    <h:message id="errors2" for="Password" style="color: red"/>
   </p>
@end smallexample
@itemize @bullet
@item 
The commandButton is the ``Submit'' button.  It calls the backing bean's login() method
@end itemize
@smallexample
   <h:commandButton id="goodbyeCommand" type="submit" value="Login" 
                    action="#{atmServiceBackingBean.login}" />
  </h:form>
 </body>
</html>
@end smallexample


@node Template
@section Template

Facelet's templates are useful in cases where multiple pages have a similar structure.
In this case, I'm using a template to define the navigational bars.

@smallexample
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:h="http://java.sun.com/jsf/html">
 <body>          
  <h:form id="atmBaseForm">
   <table border="2">
    <tr>
     <td>            
@end smallexample
@itemize @bullet
@item 
An outputlink is like an HREF
@end itemize
@smallexample
      <h:outputLink value="currentBalance.xhtml">Current Balance
      </h:outputLink>
     </td>
     <td>
      <h:outputLink value="withdraw.xhtml">Withdraw
      </h:outputLink>                                               
     </td>
     <td>
      <h:outputLink value="deposit.xhtml">Deposit
      </h:outputLink>                        
     </td>
     <td>
      <h:outputLink value="transactionHistory.xhtml" >Transaction History
      </h:outputLink>                        
     </td>
    </tr>
   </table>
   <br/>
  </h:form>
@end smallexample
@itemize @bullet
@item 
Any page which uses this template will override this default body
@end itemize
@smallexample
  <ui:insert name="body">Default Body</ui:insert>
 </body>
</html>
@end smallexample



@node Welcome page
@section Welcome page

@smallexample
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:h="http://java.sun.com/jsf/html">
 <body>
@end smallexample
@itemize @bullet
@item 
Use the template, and override the body component
@end itemize
@smallexample
  <ui:composition template="/template.xhtml">

  <ui:define name="body">
   <h:form id="mainForm">
    <p>
     <h:outputText value="Hello @#@{atmServiceBackingBean.username@}" />
     <br/>
    </p>
   </h:form>
  </ui:define>            
  </ui:composition >
 </body>
</html>
@end smallexample



@node Current Balance page
@section Current Balance page

@smallexample

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:t="http://myfaces.apache.org/tomahawk"
      xmlns:h="http://java.sun.com/jsf/html">
 <body>
  <ui:composition template="/template.xhtml">
  <ui:define name="body">
  <h:form id="currentBalanceForm">
  <p>
   <h:outputLabel for="currentBalanceLabel">                        
   <h:outputText id="currentBalance"
   value="Current Balance: @#@{atmServiceBackingBean.atmService.balance@}"/>                            
   </h:outputLabel>                                            
  </p>
  </h:form>                
  </ui:define>
  </ui:composition >
 </body>
</html>
@end smallexample


@node Withdraw page
@section Withdraw page

@smallexample


<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:f="http://java.sun.com/jsf/core"
      xmlns:h="http://java.sun.com/jsf/html">
 <body>
  <ui:composition template="/template.xhtml">
  <ui:define name="body">
   <h:form id="withdrawalForm">                
    <p>
    <h:outputLabel for="withdrawalInput">
    <h:outputText id="withdrawalInputLabel"
                  value="Amount To Withdraw:"/>
    </h:outputLabel>
    <h:inputText id="withdrawalInput" 
                 value="@#@{atmServiceBackingBean.withdrawal@}" 
                 required="true">
    </h:inputText>
   <h:message id="errors" for="withdrawalInput" style="color: red"/>
   </p>
   <h:commandButton id="withdrawCommand" type="submit" value="Withdraw" 
                   action="@#@{atmServiceBackingBean.withdraw@}" />                
   </h:form>                
  </ui:define>
 </ui:composition >
 </body>
</html>
@end smallexample


@node Deposit page
@section Deposit page

@smallexample

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:f="http://java.sun.com/jsf/core"
      xmlns:h="http://java.sun.com/jsf/html">
 <body>
  <ui:composition template="/template.xhtml">
  <ui:define name="body">
   <h:form id="depositForm">                
   <p>
    <h:outputLabel for="depositInput">
     <h:outputText id="depositInputLabel"
                   value="Amount To Deposit:"/>
     </h:outputLabel>
     <h:inputText id="depositInput" 
                  value="@#@{atmServiceBackingBean.deposit@}" 
                  required="true">
     </h:inputText>
     <h:message id="errors" for="depositInput" style="color: red"/>
   </p>
            
   <h:commandButton id="depositCommand" type="submit" value="Deposit" 
                    action="@#@{atmServiceBackingBean.deposit@}" />                
   </h:form>                  
  </ui:define>
 </ui:composition >
 </body>
</html>
@end smallexample


@node FundTransfer History page
@section FundTransfer History page

@smallexample

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:f="http://java.sun.com/jsf/core"
      xmlns:h="http://java.sun.com/jsf/html">
 <body>
 <ui:composition template="/template.xhtml">
 <ui:define name="body">
  <h:form id="transactionHistoryForm">

@end smallexample
@itemize @bullet
@item 
A dataTable loops over a ListDataModel, binding each elemnent to
the ``transaction'' variable
@end itemize
@smallexample
  <h:dataTable id="transactions" 
               value="@#@{atmServiceBackingBean.transactions@}" 
               var="transaction">		
  <h:column>
   <f:facet name="header">
    <h:outputText  value="Account ID"/>
   </f:facet>                            
   <h:outputText value="@#@{transaction.account.id@}"/>
  </h:column>
  <h:column>
   <f:facet name="header">
    <h:outputText  value="Transaction Date"/>
   </f:facet>                            
  <h:outputText value="@#@{transaction.date.time@}"/>
  </h:column>
  <h:column>
   <f:facet name="header">
    <h:outputText  value="Balance Before Transaction"/>
   </f:facet>                            
   <h:outputText value="@#@{transaction.balanceBeforeTransaction@}"/>
  </h:column>
  <h:column>
   <f:facet name="header">
    <h:outputText  value="Balance After Transaction"/>
   </f:facet>                            
   <h:outputText value="@#@{transaction.balanceAfterTransaction@}"/>
  </h:column>                        
  <h:column>
   <f:facet name="header">
    <h:outputText  value="Transaction Details"/>
   </f:facet>                            
@end smallexample
@itemize @bullet
@item 
This link calls the viewSingleTransaction method.  This method will have to inspect
the DataModel to see which row was chosen.
@end itemize
@smallexample   
    <h:commandLink action="@#@{atmServiceBackingBean.viewSingleTransaction@}">                                 
    <h:outputText value="Transaction Details"/>                                 
   </h:commandLink>                                                     
  </h:column>                        
 </h:dataTable>                        	
 </h:form>
</ui:define>
</ui:composition >
</body>
</html>
@end smallexample


@node FundTransfer  page
@section FundTransfer page

@smallexample

<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:ui="http://java.sun.com/jsf/facelets"
      xmlns:f="http://java.sun.com/jsf/core"
      xmlns:h="http://java.sun.com/jsf/html">
 <body>
  <ui:composition template="/template.xhtml">
  <ui:define name="body">
   <h:form id="transactionHistoryForm">
   <p>
@end smallexample
@itemize @bullet
@item 
Since the viewSingleTransaction set the current row to ``selectecTransaction'',
this page can access the single record
@end itemize
@smallexample   <h:outputText id="deposit"
    value="On @#@{atmServiceBackingBean.selectedTransaction.date.time@}, 
    you committed a transaction on account 
    @#@{atmServiceBackingBean.selectedTransaction.account.id@} 
    to change your balance from 
    @#@{atmServiceBackingBean.selectedTransaction.balanceBeforeTransaction@} 
    to 
    @#@{atmServiceBackingBean.selectedTransaction.balanceAfterTransaction@}
    "/>
   </p>                                        
   </h:form>
  </ui:define>
  </ui:composition >
 </body>
</html>
@end smallexample



@node BackingBean
@section BackingBean

The BackingBean is an object which resides on the server side which holds
onto the state of the application.  When a Facelet page binds to a variable
in this class, it doesn't directly set the fields, it follows the JavaBean
standard of calling the get/set methods.

@smallexample

public class ATMServiceBackingBean @{
 public ATMServiceBackingBean() @{
   atmService = new Main().getAtmService();
 @}
@end smallexample
@itemize @bullet
@item 
Since username and password were bound by JSF, I know that these fields
are populated.  JSF requires these action methods to return a String that
JSF will use for page navigation
@end itemize
@smallexample
 public String login() @{
     if (atmService.authenticate(username, password))
         return "loginSuccess";
     return "loginFailure";
 @}
@end smallexample
@itemize @bullet
@item 
This shows how to add a custom message to a component.  If the
user didn't enter a number, a message is added to the component
in form ``withdrawalForm'' with id ``withdrawalInput''
@end itemize
@smallexample public String withdraw() @{
    FacesContext context = FacesContext.getCurrentInstance();
     try@{
         Double amountToWithdraw = Double.parseDouble(withdrawal);
         atmService.withdraw(amountToWithdraw);
         return "transactionSuccess";
     @} catch(NumberFormatException nfe) @{
         context.addMessage("withdrawalForm:withdrawalInput", 
                   new FacesMessage("Please enter a decimal number"));
         return "transactionFailure";
     @}
 @}
 public String deposit() @{
     FacesContext context = FacesContext.getCurrentInstance();
     try@{
        Double amountToDeposit = Double.parseDouble(deposit);
         atmService.deposit(amountToDeposit);
         return "transactionSuccess";
     @} catch(NumberFormatException nfe) @{
         context.addMessage("depositForm:depositInput", 
                   new FacesMessage("Please enter a decimal number"));
         return "transactionFailure";
     @}
 @}
@end smallexample
@itemize @bullet
@item 
When an individual row in the fund transfer table is selected, the backing
bean needs to get the element that was selected.
@end itemize
@smallexample
 public String viewSingleTransaction() @{
     selectedTransaction = (FundTransfer) transactions.getRowData();
     return "viewTransactionDetails";
 @}
@end smallexample
@itemize @bullet
@item 
JSF requires that a java.util.List is wrapped with a JSF model component
@end itemize
@smallexample public DataModel getTransactions() @{
     transactions = new ListDataModel();
     ArrayList<FundTransfer> wrappedList = new ArrayList<FundTransfer>();
     wrappedList.addAll(
        atmService.fetchFundTransferHistory().getFundTransferHistory());
     transactions.setWrappedData(wrappedList);
     return transactions;
 @}
 ..........getters/setters...............
 private ATMService atmService;
 private String username;
 private String password;
 private String withdrawal;
 private String deposit;
 private DataModel transactions ;
 private FundTransfer selectedTransaction;
    
@}
@end smallexample


@node faces-config.xml
@section faces-config.xml

The faces-config.xml file is responsible for instantiating backing beans,
and defining page flow between the pages.  It's pretty self explanatory.

@smallexample

<faces-config>
 <application>
   <view-handler>
    com.sun.facelets.FaceletViewHandler
   </view-handler>    
 </application>   
 
 <navigation-rule>
  <description>Navigation from the login page.</description>
   <from-view-id>/login.xhtml</from-view-id>
    <navigation-case>
     <from-outcome>loginSuccess</from-outcome>
     <to-view-id>/main.xhtml</to-view-id>
    </navigation-case>
    <navigation-case>
     <from-outcome>loginFailure</from-outcome>
     <to-view-id>/login.xhtml</to-view-id>
    </navigation-case>
   </navigation-rule>

   <navigation-rule>
    <description>Navigation from the withdrawal page.</description>
     <from-view-id>/withdraw.xhtml</from-view-id>
     <navigation-case>
      <from-outcome>transactionSuccess</from-outcome>
      <to-view-id>/currentBalance.xhtml</to-view-id>
     </navigation-case>
     <navigation-case>
      <from-outcome>transactionFailure</from-outcome>
      <to-view-id>/withdraw.xhtml</to-view-id>
     </navigation-case>
    </navigation-rule>

    <navigation-rule>
     <description>Navigation from the deposit page.</description>
     <from-view-id>/deposit.xhtml</from-view-id>
      <navigation-case>
       <from-outcome>transactionSuccess</from-outcome>
       <to-view-id>/currentBalance.xhtml</to-view-id>
      </navigation-case>
      <navigation-case>
       <from-outcome>transactionFailure</from-outcome>
       <to-view-id>/deposit.xhtml</to-view-id>
      </navigation-case>
    </navigation-rule>

    <navigation-rule>
     <description>Navigation from the Transaction History page.
     </description>
     <from-view-id>/transactionHistory.xhtml</from-view-id>
     <navigation-case>
      <from-outcome>viewTransactionDetails</from-outcome>
      <to-view-id>/viewTransactionDetails.xhtml</to-view-id>
     </navigation-case>
    </navigation-rule>
    
    <managed-bean>
     <description>Backing bean used for logging into the ATM system
     </description>
     <managed-bean-name>atmServiceBackingBean</managed-bean-name>
     <managed-bean-class>
       com.billsix.examples.atm.webclient.ATMServiceBackingBean
     </managed-bean-class>
     <managed-bean-scope>session</managed-bean-scope>
    </managed-bean>
    
</faces-config>

@end smallexample


@node Conclusion
@chapter Conclusion

Hibernate solves the object-relational impedance mismatch while performing efficiently.
Spring simplifies transaction management by offering a uniform transaction management scheme.
JavaServer Faces faciliates exposing the Domain Model in web forms almost as easily
as with rich clients.


This document, and all sample code can be downloaded from anonymously via subversion.

@smallexample
svn co https://atmexample.svn.sourceforge.net/svnroot/atmexample
@end smallexample





@c Local Variables:
@c ispell-local-pdict: "ispell-dict"
@c End:
@bye

